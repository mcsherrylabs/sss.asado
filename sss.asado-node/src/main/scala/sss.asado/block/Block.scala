package sss.asado.block

import sss.ancillary.Logging
import sss.asado.chains.Chains.GlobalChainIdMask
import sss.asado.common.block._
import sss.asado.ledger._
import sss.asado.util.ByteArrayEncodedStrOps._
import sss.db._

import scala.util.{Failure, Success, Try}


object Block extends Logging {

  private val blockTableNamePrefix = "block_"
  //private lazy val blockCache = new SynchronizedLruMap[(GlobalChainIdMask, Long), Block](100)
  def makeTableName(height: Long, chainId: GlobalChainIdMask) = s"$blockTableNamePrefix${height}_${chainId}"
  def apply(height: Long)(implicit db:Db, chainId: GlobalChainIdMask): Block = new Block(height) //blockCache.getOrElseUpdate((chainId, height), new Block(height))

  def drop(height: Long)(implicit db:Db, chainId: GlobalChainIdMask) = {
    val tblName = makeTableName(height, chainId)
    Try(db.executeSql(s"DROP TABLE $tblName")) match {
      case Failure(e) => log.debug(s"Exception, table ${tblName} probably doesn't exist.")
      case Success(_) =>
    }
  }

}

class Block(val height: Long)(implicit db:Db, chainId: GlobalChainIdMask) extends Logging {

  import Block._

  private val tableName = makeTableName(height, chainId)
  private val id = "id"
  private val txid = "txid"
  private val entry = "entry"
  private val committed = "committed"
  private val rejected = "rejected"

  db.executeSql (s"CREATE TABLE IF NOT EXISTS $tableName (" +
    s"$id BIGINT GENERATED BY DEFAULT AS IDENTITY (START WITH 1, INCREMENT BY 1), " +
    s"$txid VARCHAR(64) NOT NULL, " +
    s"$entry BLOB, " +
    s"$rejected BOOLEAN DEFAULT FALSE NOT NULL, " +
    s"$committed BOOLEAN DEFAULT FALSE NOT NULL, " +
    s"PRIMARY KEY($id), UNIQUE($txid));")


  private val blockTxTable = db.table(tableName)

  private[block] def truncate: Unit = db.executeSql(s"TRUNCATE TABLE $tableName")

  def entries: Seq[BlockTx] = {
    blockTxTable.map (toBlockTx, OrderAsc(id))
  }

  private def toBlockTx(r: Row): BlockTx = BlockTx(r[Long](id), r[Array[Byte]](entry).toLedgerItem)

  def page(index: Long, pageSize: Int): Seq[Either[Array[Byte], Array[Byte]]] = {
    var count = 0
    assert(index != 0, "1 based index for pages")
    blockTxTable.filter(
      where(s"$id >= ? AND $committed = ?", index, true)
        .orderBy(OrderAsc(id))
        .limit(pageSize))
      .map { r =>
        require(r[Long](id) == index + count, s"row: $r, index: $index count: $count")
        count += 1
        if(r[Boolean](rejected)) Right(r[String](txid).toByteArray)
        else Left(r[Array[Byte]](entry))
      }

  }

  def apply(k: TxId): BlockTx = get(k).get

  def count = blockTxTable.count

  def validateTx[T](f: => T): Try[T] = {
      val r = blockTxTable.validateTx(f)
      blockTxTable.setNextIdToMaxIdPlusOne()
      r
  }

  def inTransaction[T](f: => T): T = blockTxTable.inTransaction[T](f)

  def inTransaction[T](f: => Try[T]): Try[T] = blockTxTable.tx[T](f)

  def get(id: TxId): Option[BlockTx] =
    blockTxTable.find(
      where(txid -> id.toBase64Str))
      .map(toBlockTx)

  def journal(index: Long, le: LedgerItem): Long = {
    val bs = le.toBytes
    val hexStr = le.txId.toBase64Str
    val row = blockTxTable.insert(Map(id -> index, txid -> hexStr, entry -> bs))
    row(id)
  }

  def reject(bTxId: BlockTxId): Try[Unit] = blockTxTable.inTransaction {
    Try {
      blockTxTable.find(
        where(
          id -> bTxId.index)) match {
        case None =>
          require(get(bTxId.txId).isEmpty, "Very wrong ")
          val newRow = blockTxTable.insert(Map(txid -> bTxId.txId, rejected -> true))
          require(newRow.id == bTxId.index, "The local block auto increment is out of sync with the leader block")

        case Some(row) =>
          require(row[String](txid) == bTxId.txId.toBase64Str, "Very wrong ")
          blockTxTable.update(Map(id -> bTxId.index, rejected -> true))
      }
    }
  }

  def getUnCommitted: Seq[BlockTx] = blockTxTable.filter(
    where(committed -> false)
      .orderBy(OrderAsc(id)))
       .map (toBlockTx)

  def getLastRecorded: Long = blockTxTable.maxId

  def getLastCommitted: Long = {
    blockTxTable.find(
      where(committed -> true)
        .orderBy(OrderDesc(id))
        .limit(1)
    )
      .map(_[Long](id))
      .getOrElse(0)
  }

  def commit(index: Long): Unit = {
    blockTxTable.update(Map(id -> index, committed -> true))
  }

  def write(index: Long, le: LedgerItem): Long = {
    val bs = le.toBytes
    val hexStr: String = le.txId.toBase64Str
    val row = Try {
      blockTxTable.insert(Map(id -> index, txid -> hexStr, entry -> bs, committed -> true))
    } getOrElse {
      log.info(s"Ledger index $index already exists, try updating...")
      blockTxTable.update(Map(id -> index, txid -> hexStr, entry -> bs, committed -> true))
    }
    row(id)
  }

  def write(le: LedgerItem): Long = {
    val bs = le.toBytes
    val hexStr: String = le.txId.toBase64Str
    val row = blockTxTable.insert(Map(txid -> hexStr, entry -> bs, committed -> true))
    row(id)
  }

}
