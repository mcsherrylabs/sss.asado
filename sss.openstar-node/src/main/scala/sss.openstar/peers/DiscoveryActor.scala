package sss.openstar.peers

import java.net.{InetAddress, InetSocketAddress}

import akka.actor.Actor
import sss.db._
import sss.openstar.chains.Chains.GlobalChainIdMask
import sss.openstar.network.{MessageEventBus, NodeId}
import sss.openstar.{Send, UniqueNodeIdentifier}



trait Discovery {
  def find(notIncluding: Set[UniqueNodeIdentifier], numConns: Int, caps: GlobalChainIdMask): Seq[NodeId]
  def lookup(names: Set[UniqueNodeIdentifier]): Seq[NodeId]
  def insert(nodeId:NodeId, supportedChains: GlobalChainIdMask): Unit
  def discover(seedConns: Set[UniqueNodeIdentifier])
}

class DiscoveryImpl(implicit db: Db) extends Discovery {

  private val discoveryTableName = "discovery"
  private val nIdCol = "nid_col"
  private val addrCol = "addr_col"
  private val portCol = "port_col"
  private val capCol = "cap_col"

  private val createTableSql =
    s"""CREATE TABLE IF NOT EXISTS $discoveryTableName
       |(id BIGINT GENERATED BY DEFAULT AS IDENTITY (START WITH 1, INCREMENT BY 1),
       |$nIdCol VARCHAR(100),
       |$addrCol BINARY(16),
       |$portCol INT NOT NULL,
       |$capCol BINARY(1) NOT NULL,
       |PRIMARY KEY(id), UNIQUE($addrCol));
       |""".stripMargin

  private val indx = s"CREATE INDEX IF NOT EXISTS ${discoveryTableName}_indx ON $discoveryTableName ($addrCol, $capCol);"

  lazy val discoveryTable = {
    db.executeSqls(Seq(createTableSql, indx))
    db.table(discoveryTableName)
  }

  override def find(notIncluding: Set[UniqueNodeIdentifier], numConns: Int, caps: GlobalChainIdMask): Seq[NodeId] = {
    //TODO SQL INJECTION ATTACK HERE????
    val sql = if(!notIncluding.isEmpty) {
      val massagedNames = notIncluding map (name => s"'$name'") mkString (",")
      s" $nIdCol NOT IN ($massagedNames) AND $capCol = ?"
    } else s"$capCol = ?"

    discoveryTable.map ({ r =>
      val inet = r[Array[Byte]](addrCol).toInetAddress
      val sock = new InetSocketAddress(inet, r[Int](portCol))
      NodeId(r[String](nIdCol), sock )
    }, where(sql, caps).limit(numConns))

  }

  override def lookup(names: Set[UniqueNodeIdentifier]): Seq[NodeId] = {

    val massagedNames = names map (name => s"'$name'") mkString (",")
    discoveryTable.map ({ r =>
      val inet = r[Array[Byte]](addrCol).toInetAddress
      val sock = new InetSocketAddress(inet, r[Int](portCol))
      NodeId(r[String](nIdCol), sock )
    }, where(s" $nIdCol IN ($massagedNames)"))

  }

  override def insert(nodeId:NodeId, supportedChains: GlobalChainIdMask): Unit = {

    discoveryTable.insert(
      Map(
        nIdCol -> nodeId.id,
        addrCol -> nodeId.inetSocketAddress.getAddress.toBytes,
        portCol -> nodeId.inetSocketAddress.getPort,
        capCol -> supportedChains)
    )
  }

  override def discover(seedConns: Set[UniqueNodeIdentifier]): Unit = ???
}

class DiscoveryActor(seedNodes: Set[UniqueNodeIdentifier])
                    (implicit messageEventBus: MessageEventBus,
                     send: Send) extends Actor {


    override def receive: Receive = ???
}
