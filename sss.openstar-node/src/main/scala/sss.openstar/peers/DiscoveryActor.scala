package sss.openstar.peers

import java.net.InetSocketAddress

import akka.actor.{Actor, ActorLogging, Props}
import akka.util.ByteString
import sss.db._
import sss.openstar.chains.Chains.GlobalChainIdMask
import sss.openstar.network.MessageEventBus.IncomingMessage
import sss.openstar.network.{MessageEventBus, NodeId, SerializedMessage}
import sss.openstar.peers.DiscoveryActor.{Discover, DiscoveredNode}
import sss.openstar.{MessageKeys, OpenstarEvent, Send, UniqueNodeIdentifier}

import scala.util.{Random, Try}

class Discovery(implicit db: Db) {

  private val discoveryTableName = "discovery"
  private val nIdCol = "nid_col"
  private val addrCol = "addr_col"
  private val portCol = "port_col"
  private val capCol = "cap_col"
  private val idCol = "id"

  private val createTableSql =
    s"""CREATE TABLE IF NOT EXISTS $discoveryTableName
       |($idCol BIGINT GENERATED BY DEFAULT AS IDENTITY (START WITH 1, INCREMENT BY 1),
       |$nIdCol VARCHAR(100),
       |$addrCol BINARY(16),
       |$portCol INT NOT NULL,
       |$capCol BINARY(1) NOT NULL,
       |PRIMARY KEY(id), UNIQUE($addrCol));
       |""".stripMargin

  private val indx = s"CREATE INDEX IF NOT EXISTS ${discoveryTableName}_indx ON $discoveryTableName ($addrCol, $capCol);"

  lazy val discoveryTable = {
    db.executeSqls(Seq(createTableSql, indx))
    db.table(discoveryTableName)
  }

  def find(nodesToIgnore: Set[UniqueNodeIdentifier], numConns: Int, caps: GlobalChainIdMask): Seq[DiscoveredNode] = {
    viewToDiscoveredNodes(
      where(capCol -> caps) and where(nIdCol) notIn nodesToIgnore limit numConns
    )
  }

  def lookup(names: Set[UniqueNodeIdentifier]): Seq[DiscoveredNode] = {
    viewToDiscoveredNodes(where(nIdCol) in names)
  }

  private def viewToDiscoveredNodes(filter: Where): Seq[DiscoveredNode] = {
    discoveryTable
      .map(
        rowToDiscoveredNode, filter
      )
  }

  private def rowToDiscoveredNode(r:Row): DiscoveredNode = {
    val inet = r[Array[Byte]](addrCol).toInetAddress
    val sock = new InetSocketAddress(inet, r[Int](portCol))
    DiscoveredNode(NodeId(r[String](nIdCol), sock), r[Byte](capCol))
  }

  def insert(nodeId:NodeId, supportedChains: GlobalChainIdMask): Try[DiscoveredNode] = {

    Try(discoveryTable insert
      Map(
        nIdCol -> nodeId.id,
        addrCol -> nodeId.inetSocketAddress.getAddress.toBytes,
        portCol -> nodeId.inetSocketAddress.getPort,
        capCol -> supportedChains)
    ) map rowToDiscoveredNode
  }

  def query(start: Int, pageSize: Int): (Seq[DiscoveredNode], ByteString) = {
    val nodes = viewToDiscoveredNodes (where(s"$idCol > ?", start) limit pageSize)
    (nodes, ByteString.empty)
  }

}

object DiscoveryActor {

  def props(discovery: Discovery)
           (implicit events: MessageEventBus,
            send: Send): Props = Props(classOf[DiscoveryActor], discovery, events, send)

  case class DiscoveredNode(nodeId: NodeId, capabilities: GlobalChainIdMask) extends OpenstarEvent
  case class Discover(seeds: Set[UniqueNodeIdentifier]) extends OpenstarEvent
}

class DiscoveryActor(
                     discovery: Discovery)
                    (implicit events: MessageEventBus,
                     send: Send) extends Actor with ActorLogging {

  import SerializedMessage.noChain

  events subscribe MessageKeys.SeqPeerPageResponse
  events subscribe MessageKeys.PeerPage
  events subscribe classOf[Discover]

    override def receive: Receive = {

      case Discover(seeds) if (seeds.nonEmpty) =>
        val conn = seeds.toSeq(Random.nextInt(seeds.size))
        val msg = PeerPage(0, 1000, ByteString("FIXME" + Random.nextInt()))

        send(MessageKeys.PeerPage, msg, conn)


      case IncomingMessage(_, MessageKeys.PeerPage, fromNode, PeerPage(start, end, fingerPrint)) =>
        val (discoveredNodes, localFingerPrint) = discovery.query(start, end)

        if(fingerPrint != localFingerPrint) {

          val asResponses = discoveredNodes map (dn =>
            PeerPageResponse(
              dn.nodeId.id,
              dn.nodeId.inetSocketAddress,
              Capabilities(dn.capabilities)
            ))

          send(MessageKeys.SeqPeerPageResponse, SeqPeerPageResponse(asResponses), fromNode)
          send(MessageKeys.PeerPage, PeerPage(start, end, localFingerPrint), fromNode)
        }


      case IncomingMessage(_, MessageKeys.SeqPeerPageResponse, fromNode, SeqPeerPageResponse(seq)) =>
        seq foreach (self ! _)


      case PeerPageResponse(nodeId, socketAddr, capabilities) =>
        discovery
          .insert(
            NodeId(nodeId, socketAddr),
            capabilities.supportedChains
          ) recover {
          case e =>
            log.debug("Couldn't process {} {}, possible dup", nodeId, socketAddr)
            log.debug(e.toString)
        }

    }
}
