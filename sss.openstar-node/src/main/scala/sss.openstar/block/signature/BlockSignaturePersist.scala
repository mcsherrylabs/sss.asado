package sss.openstar.block.signature


import java.sql.SQLIntegrityConstraintViolationException
import java.util

import org.joda.time.DateTime
import scorex.crypto.signatures.SigningFunctions._
import sss.ancillary.Logging
import sss.openstar.chains.Chains.GlobalChainIdMask
import sss.db.{Db, OrderAsc, Row}

import sss.openstar.util.ByteArrayEncodedStrOps._
import scala.util.{Failure, Success, Try}


trait BlockSignatures {
  val height: Long
  import BlockSignatures._
  def signatures(maxToReturn: Int): Seq[BlockSignature]
  def write(blkSigs: Seq[BlockSignature]): Seq[BlockSignature]
  def write(blkSig: BlockSignature): BlockSignature
  def add(signature: Signature, signersPublicKey: PublicKey, nodeId: String): BlockSignature
  def indexOfBlockSignature(nodeId: String): Option[Int]
}

object BlockSignatures {

  import sss.openstar.util.ByteArrayComparisonOps._

  object QuorumSigs {
    def apply(height: Long)
             (implicit db: Db,chainId: GlobalChainIdMask): BlockSignatures =
      new BlockSignaturePersister("quorum", height)
  }

  object NonQuorumSigs {
    def apply(height: Long)
             (implicit db: Db,chainId: GlobalChainIdMask): BlockSignatures =
      new BlockSignaturePersister("non_quorum", height)
  }

  case class BlockSignature(index: Int,
                            savedAt: DateTime,
                            height: Long,
                            nodeId: String,
                            publicKey: PublicKey,
                            signature: Signature)  {
    val asMap = Map(id -> index,
      created_dt_str -> savedAt.getMillis,
      signature_str -> signature,
      public_key_str -> publicKey,
      nodeId_str -> nodeId
      )

    override def equals(obj: scala.Any): Boolean = obj match {
      case blkSig: BlockSignature => blkSig.height == height &&
        blkSig.nodeId == nodeId &&
        blkSig.index == index &&
        blkSig.savedAt == savedAt &&
        blkSig.publicKey.isSame(publicKey) &&
        blkSig.signature.isSame(signature)
      case _ => false
    }
    override def toString: String = s"Index: $index, " +
      s"SavedAt: $savedAt, " +
      s"Height: $height, NodeId: $nodeId, " +
      s"PK:${publicKey.toBase64Str}, " +
      s"Sig: ${signature.toBase64Str}"


    override def hashCode(): Int =
      height.hashCode() +
        nodeId.hashCode +
        index.hashCode() +
        savedAt.hashCode() +
        util.Arrays.hashCode(publicKey) +
        util.Arrays.hashCode(signature)
  }

  private val id = "id"
  private val nodeId_str = "nodeId"
  private val created_dt_str = "created_dt"
  private val signature_str = "signature"
  private val public_key_str = "public_key"


  private class BlockSignaturePersister(tableTag: String,
                                        val height: Long)
                                       (implicit db: Db,
                                        chainId: GlobalChainIdMask)
    extends BlockSignatures with Logging{

    private lazy val tableName = s"block_sigs_${tableTag}_${chainId}_$height"

    private def createTableSql =
      s"""CREATE TABLE IF NOT EXISTS $tableName
          |($id INT GENERATED BY DEFAULT AS IDENTITY (START WITH 1, INCREMENT BY 1),
          |$nodeId_str VARCHAR(100),
          |$signature_str BLOB,
          |$public_key_str BLOB,
          |$created_dt_str BIGINT,
          |PRIMARY KEY($nodeId_str));
          |""".stripMargin

    private lazy val table = {
      db.executeSql(createTableSql)
      db.table(tableName)
    }

    /**
      *
      * @param blkSig
      * @return
      */
    override def write(blkSig: BlockSignature): BlockSignature = {
      require(height == blkSig.height, "Trying to save a signature into the wrong block.")
      Try(table.insert(blkSig.asMap)) match {
        case Failure(e : SQLIntegrityConstraintViolationException) => apply(table.get(blkSig.index).get)
        case Failure(e) => throw e
        case Success(row) => apply(row)
      }
    }

    override def write(blkSigs: Seq[BlockSignature]): Seq[BlockSignature] = {
      table.tx(blkSigs.map(write(_)))
    }

    override def add(signature: Signature, signersPublicKey: PublicKey, nodeId: String) = {

      apply(table.insert(Map(nodeId_str -> nodeId,
        created_dt_str -> DateTime.now.getMillis,
        signature_str -> signature,
        public_key_str -> signersPublicKey
      )))
    }

    override def indexOfBlockSignature(nodeId: String): Option[Int] = {
      table.find(nodeId_str -> nodeId) map( r => r[Int](id))
    }

    override def signatures(maxToReturn: Int): Seq[BlockSignature] = {
      table.page(0, maxToReturn, Seq(OrderAsc(id))) map (apply)
    }

    def apply(row: Row): BlockSignature =
      BlockSignature(row[Int](id),
        new DateTime(row[Long](created_dt_str)),
        height,
        row(nodeId_str),
        row[Array[Byte]](public_key_str),
        row[Array[Byte]](signature_str)
      )


  }
}
