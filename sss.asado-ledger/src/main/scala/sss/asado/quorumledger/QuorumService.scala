package sss.asado.quorumledger


import java.sql.SQLIntegrityConstraintViolationException

import sss.ancillary.Logging
import sss.asado.UniqueNodeIdentifier
import sss.asado.chains.Chains.GlobalChainIdMask
import sss.db._

import scala.util.{Failure, Success, Try}

/**
  *
  * @param uniqueChainId will be used as part of a db table name, only standard characters allowed.
  * @param db
  */

trait QuorumServiceQuery {
  def candidates(): Set[UniqueNodeIdentifier]
}

class QuorumService(private [quorumledger] val uniqueChainId: GlobalChainIdMask)(implicit db:Db)
  extends QuorumServiceQuery with Logging {

  private val quorumTableName = s"quorum_tbl_$uniqueChainId"
  private val id = "id"
  private val identityCol = "identity_col"

  // no duplicate mambers allowed via PK
  private val createQuorumTableSql =
    s"""CREATE TABLE IF NOT EXISTS ${quorumTableName}
       |($id BIGINT GENERATED BY DEFAULT AS IDENTITY (START WITH 1, INCREMENT BY 1) UNIQUE,
       |$identityCol VARCHAR(100),
       |PRIMARY KEY($identityCol));
       |""".stripMargin

  db.executeSql(createQuorumTableSql)

  private lazy val table = db.table(quorumTableName)

  override def candidates(): Set[UniqueNodeIdentifier] = {
    (for {
      r <- table
    } yield(r[String](identityCol))).toSet
  }

  def add(newCandidate: UniqueNodeIdentifier): Set[UniqueNodeIdentifier] = {
    Try (table persist (Map(identityCol -> newCandidate))) match {
      case Failure(e: SQLIntegrityConstraintViolationException) =>
        log.warn(s"Attempted to add existing member as newMember. $newCandidate")
        candidates()
      case Failure(e) => throw e
      case Success(_) => candidates()
    }
  }

  def remove(candidate: UniqueNodeIdentifier): Set[UniqueNodeIdentifier] = {
    val deleted = table.delete(where(identityCol -> candidate))
    assert(deleted == 1 || deleted == 0, s"$deleted rows deleted from quorum ledger $uniqueChainId, should only be 0 or 1")
    candidates()
  }

}
